package rules.Ava;

import java.util.*;
import java.util.ArrayList;
import java.util.List;

import com.mindsmiths.armory.events.UserConnectedEvent
import com.mindsmiths.armory.events.SubmitEvent
import com.mindsmiths.ruleEngine.model.Heartbeat;
import com.mindsmiths.ruleEngine.util.Agents;
import com.mindsmiths.pairingalgorithm.Days;
import com.mindsmiths.pairingalgorithm.AvaAvailability;
import static com.mindsmiths.ruleEngine.util.DateUtil.evaluateCronExpression;

import agents.Ava;
import agents.CultureMaster;

import signals.AvaAvailabilitySignal;
import signals.SendMatchesSignal;

import models.AvaLunchCycleStage;
import models.OnboardingStage;
import models.LunchReminderStage;

rule "Send first reminder email"
    when
        Heartbeat(ts: timestamp) from entry-point "signals"
        eval(evaluateCronExpression("* * 11 ? * THU *", ts, "Europe/Zagreb"))
        agent: Ava(lunchCycleStage == AvaLunchCycleStage.LUNCH_MAIL_SENDING,
                   onboardingStage == OnboardingStage.FINISHED,
                   lunchReminderStage != LunchReminderStage.USER_RESPONDED)
        employee: EmployeeProfile() 
    then
        modify(agent) {
            setLunchCycleStage(AvaLunchCycleStage.FIND_AVAILABILITY),
            setLunchReminderStage(LunchReminderStage.FIRST_REMINDER)
        }
        agent.sendWeeklyEmail(employee);

        
end

rule "Send second reminder email"
    when
        Heartbeat(ts: timestamp) from entry-point "signals"
        eval(evaluateCronExpression("* * 13 ? * FRI *", ts, "Europe/Zagreb"))
        agent: Ava(lunchCycleStage == AvaLunchCycleStage.LUNCH_MAIL_SENDING,
                   onboardingStage == OnboardingStage.FINISHED,
                   lunchReminderStage != LunchReminderStage.USER_RESPONDED)
        employee: EmployeeProfile()
    then
        modify(agent) {
            setLunchCycleStage(AvaLunchCycleStage.FIND_AVAILABILITY),
            setLunchReminderStage(LunchReminderStage.SECOND_REMINDER)
        }

end

rule "Send available days email"
    when
        Heartbeat(ts: timestamp) from entry-point "signals"
        agent: Ava(lunchCycleStage == AvaLunchCycleStage.LUNCH_MAIL_SENDING,
                   onboardingStage == OnboardingStage.FINISHED, trigger: manualTrigger)
        eval(evaluateCronExpression("* * 8-17 ? * WED *", ts, "Europe/Zagreb")
            || (trigger == true))
        employee: EmployeeProfile()
    then
        modify(agent) {setLunchCycleStage(AvaLunchCycleStage.FIND_AVAILABILITY),
                       setLunchReminderStage(LunchReminderStage.EMAIL_SENT)}
        agent.sendWeeklyEmail(employee);
end

rule "Ask for available days"
    when
        Heartbeat(ts: timestamp) from entry-point "signals"
        signal: UserConnectedEvent(getParamAsString("trigger") == "start-weekly-core") from entry-point "signals"
        agent: Ava(lunchCycleStage == AvaLunchCycleStage.FIND_AVAILABILITY,
                   onboardingStage == OnboardingStage.FINISHED, trigger: manualTrigger)
        eval(evaluateCronExpression("* * 9-23 * * WED", ts, "Europe/Zagreb") 
            || (evaluateCronExpression("* * * * * THU", ts, "Europe/Zagreb"))
            || (evaluateCronExpression("* * 00-18 * * MON", ts, "Europe/Zagreb"))
            || (trigger== true))
    then 
        // what if person decides to exit this screen without answering, now we can't get back because we are in the next stage
        modify(agent) {
            setLunchCycleStage(AvaLunchCycleStage.FORWARD_AVAILABILITY),
            setManualTrigger(false)
        };
        agent.chooseAvailableDaysScreen();
        delete(signal);
end

rule "Handle employee not available"
    when 
        signal: SubmitEvent((getParamAsString("submit") == "confirmDays") && (signal.getParam("availableDays") == [])) from entry-point "signals"
        agent: Ava(lunchCycleStage == AvaLunchCycleStage.FORWARD_AVAILABILITY)
    then
        agent.showNotAvailableScreen();
        modify(agent) {updateAvailableDays((ArrayList<String>)(signal.getParam("availableDays")))};
        agent.send(CultureMaster.ID, new AvaAvailabilitySignal(new AvaAvailability(agent.getId(),agent.getAvailableDays()))); 
        modify(agent) {setLunchCycleStage(AvaLunchCycleStage.ACCEPT_MATCH_INFO)};
        delete(signal);
end

rule "Confirm days"
    when
        signal: SubmitEvent(getParamAsString("submit") == "confirmDays") from entry-point "signals"  
        agent: Ava(lunchCycleStage == AvaLunchCycleStage.FORWARD_AVAILABILITY)
    then
        agent.confirmingDaysScreen();
        modify(agent) {updateAvailableDays((ArrayList<String>)(signal.getParam("availableDays")))};
        agent.send(CultureMaster.ID, new AvaAvailabilitySignal(new AvaAvailability(agent.getId(), agent.getAvailableDays())));
        modify(agent) { setLunchCycleStage(AvaLunchCycleStage.ACCEPT_MATCH_INFO),
                        setLunchReminderStage(LunchReminderStage.USER_RESPONDED)
                        };
        delete(signal);
end

rule "Lunch decline reason screen"
    when
        Heartbeat(ts: timestamp) from entry-point "signals"
        signal: UserConnectedEvent(getParamAsString("trigger") == "start-lunch-decline-reason-screen") from entry-point "signals"
        agent: Ava(lunchCycleStage == AvaLunchCycleStage.FIND_AVAILABILITY,
                   onboardingStage == OnboardingStage.FINISHED)
    then 
        agent.showLunchDeclineReasonScreen();
        delete(signal);
end

rule "Finish lunch decline form"
   when
        Heartbeat(ts: timestamp) from entry-point "signals"
        signal: SubmitEvent(getParamAsString("submit") == "finished-lunch-decline-form") from entry-point "signals"
        agent: Ava(lunchReminderStage != LunchReminderStage.USER_RESPONDED)
   then
        for (String paramId : signal.getParams().keySet())
            if (paramId.startsWith("answer")){
                modify(agent) { getLunchDeclineReasons().add(signal.getParamAsString(paramId));
                        };
            }
       
        delete(signal);
end

rule "Store match info"
    when
        signal: SendMatchesSignal() from entry-point "signals"
        agent: Ava(lunchCycleStage == AvaLunchCycleStage.ACCEPT_MATCH_INFO)
        profile: EmployeeProfile()
    then
        modify(agent) {
            setMatch(signal.getMatch()), 
            setMatchDay(signal.getMatchDay())
        };
        agent.sendCalendarInvite(signal.getMatchDay(), profile, agent.getOtherEmployees().get(signal.getMatch()));
        delete(signal);   
end

rule "Reset Ava lunch cycle stage"
    when
        Heartbeat(ts: timestamp) from entry-point "signals"
        agent: Ava(lunchCycleStage == AvaLunchCycleStage.ACCEPT_MATCH_INFO)
        eval(evaluateCronExpression("* * 8-17 ? * SUN *", ts, "Europe/Zagreb"))
    then
        modify(agent) {setLunchCycleStage(AvaLunchCycleStage.LUNCH_MAIL_SENDING)};
end

rule "Lunch invite expired"
    when
        Heartbeat(ts: timestamp) from entry-point "signals"
        eval(!evaluateCronExpression("* * 9-23 * * WED", ts, "Europe/Zagreb") && 
            !evaluateCronExpression("* * * * * THU", ts, "Europe/Zagreb") &&
            !evaluateCronExpression("* * 00-14 * * FRI", ts, "Europe/Zagreb"))
        signal: UserConnectedEvent(getParamAsString("trigger") == "start-weekly-core") from entry-point "signals"
        agent: Ava(lunchCycleStage == AvaLunchCycleStage.FIND_AVAILABILITY,
                   onboardingStage == OnboardingStage.FINISHED,
                   manualTrigger == false)
    then 
        agent.showLunchInviteExpiredScreen();
        delete(signal);
end